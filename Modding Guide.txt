----------Modding?----------
This is a somewhat indepth guide to modding with Fable 2's Lua system which grants you a whole ton of control over the games scripts.

You can't create new lands, or new models, or new textures with Lua and they need to be reverse engineered too but
Lua is a vital step towards creating new content like quests, and enemies and... pretty much everything scripted.
I'm pretty sure just with access to Lua you can create your own quest where you have to kill some bandits or steal someones apple, or survive waves of enemies.
Within the scripts there's also references to content that was planned in development but didn't make it to the final game. They're a very nice find.

It's also pretty damn fun just to fly around with the freecam and spawn several trolls near some poor villagers.
  bonus points if you get the leftover Zombiemageddon script working

----------Intro----------
Fable 2 has an implementation of Lua 5.1 which it uses to drive several things including AI, UI, Cutscenes, Quests, and debugging.
We can take advantage of the implementation by modifying pre-existing Lua scripts to run our own code.

A knowledge of Lua is very advantageous, though this game drove me to learn it just so I could mess around.
Thankfully Lua has very simple syntax and is easy to pick up and use, though things can get pretty confusing the deeper you go (no thanks to the Lua documentation).
Lua is also used in plenty of other games so if you want an easier way to learn Lua, I'd start with them.
The more you understand about computers the better. I'm not good at explaining things, so this will most likely be confusing. My apologies.

To begin you must understand a couple of things.
Firstly, all of the Lua files are compiled. This means you can't immediately open 'em up and write your code inside.
  There is good news about this. There's at least 2 Lua decompilers out there. 
  The ones I know about are LuaDec (kinda sucks) and unluac which I haven't had a single problem with.
  I therefor highly recommend downloading unluac to make lua scripts readable and modifyable.
    (https://sourceforge.net/projects/unluac/)
    (Requires Java to be installed)
And secondly, the vast majority of Lua scripts are not loose and are within the .bnk files.
  A bnk file is a file archive, meaning it's a file that stores files. Think .zip files.
  There are tools out there (including mine) that manage this for you.


----------Bnk files----------
More on bnk files and where the Lua files are:
  This is somewhat confusing so bear with me.
  There are 3 banks that we are interested in.
  These are: gamescripts.bnk, gamescripts_r.bnk, and guiscripts.bnk
  It is VITAL that you understand the difference between these files.

  gamescripts_r.bnk:
  The most important bnk for Lua modding.
  Contains Lua scripts that get run in-game.
  This is the bnk we want to modify to do... anything.
  I will refer to this bnk as _r from now on. I assume _r means retail? As in scripts to be used in the final version of the game.

  gamescripts.bnk:
  Contains the same scripts as _r but these seem to not get run!
  The scripts within this bnk have *not been stripped of their debug information*.
    This means that variable names still exist and are much easier to read once decompiled.
    This bnk essentially contains a more readable version of every script that's within _r.
  I will occasionally refer to this bnk as non_r
   
   guiscripts.bnk:
   Contains scripts that manage the UI.
   These scripts seem to exist within a different Lua state and therefor their values cannot be accessed from _r or startup.
   
   startup scripts:
   There are several loose lua files in the scripts/Startup folder.
   These seem to be in their own lua state.

An EXTREMELY important thing to know is that modified scripts cannot exceed their original size (post compilation and compression).
As such, you cannot write code within a script and store it in a bnk without removing snippets of code.
This is actually not a problem as many scripts contain redundant code and more importantly we can call our own scripts at runtime that are outside of bnks, completely eliminating this issue!

----------Lua states----------
From my limited understanding, a lua state is pretty much an instance of lua and these Lua instances cannot interact with each other.
As far as I can tell there are 3 lua states.
One is in-game, where you're walking around and killing things.
One is the GUI.
One is at startup.

The ingame state has all the fun bits that we can mess around with.
The GUI state is there to run Anark's Gameface system.
The startup state, as far as I can tell, is used to initialize some things, like mounting bnks. I wish I could elaborate but I haven't looked into it too much.

----------Actually doing stuff!----------
Alright, so now you understand more about the game's Lua implementation(s?) you can set some things up.

You're going to need:
Something to extract bnks. There's a few tools out there.
  I wrote my own script for software called QuickBMS. The bms script is in this repository.
  Requires QuickBMS - http://aluigi.altervista.org/quickbms.htm
CompileCompressReplace.py (My tool to automatically reimport your modded script into a bnk) - Found in this Github repository
unluac (for decompiling scripts) - https://sourceforge.net/projects/unluac/
LuaC (for compiling the modified script), - Find it online, or compile the Lua source code.
Offzip (CompileCompressReplace requires this) - https://aluigi.altervista.org/mytoolz.htm#offzip

You'll want to create a folder dedicated to modding the Lua files that you can put your tools in (unluac, CompileCompressReplace, something for extracting from bnks).
  Don't put this folder inside of the game files, it's just a folder to work within.
  I will call this folder "Fable 2 Lua"
Within this folder I recommend creating 3 more folders called gamescripts, gamescripts_r, and guiscripts.
  These folders will contain the extracted scripts from the bnks.

----------Extracting the Lua files----------
Firstly you're going to want to extract all of the Lua files from the 3 bnks (gamescripts, _r, and guiscripts).
  You can skip guiscripts if you want, guiscripts doesn't control anything asides from the GUI, surprisingly.
  
I'm going to assume you're using my QuickBMS script for extraction. 
  If not, use whatever tool you're using to extract lua files from each bnk and put them in their respective folder, preferably keeping the file hierarchy.
  Skip to the next chapter.

To use my QuickBMS script you'll need to copy each bnk file to their new respective folders. 
  E.g Copy gamescripts.bnk into your new folder called \Fable 2 Lua\gamescripts\
  If you do not do this and select the original bnk, you will get an io error about being unable to find a file. 

For this example I'll assume you're going to start with gamescripts.bnk:
Run QuickBMS and select my script, then select the copy of gamescripts.bnk (in \Fable 2 Lua\gamescripts\), then select it again.
When you do this, a new file and folder will appear.
The file will be called *bnkname*_HEADER. Delete this.
The new folder will be called "scripts". The extracted (but still compiled) Lua scripts will be in here.
Now that the scripts have been extracted you can delete the copy of the bnk.

  Repeat for each script bnk.

At the end of this process, you should have a file hierarchy of 
\Fable 2 Lua\gamescripts\scripts\
\Fable 2 Lua\gamescripts_r\scripts\
\Fable 2 Lua\guiscripts\scripts\ (if you extracted guiscripts)

These scripts folders should contain more folders and scripts.

----------Decompiling the extracted Lua scripts----------
Now you have most of the game's Lua files but they're not readable!
That's because they're compiled, and must be decompiled into plaintext.
This is where unluac (or LuaDec if you're a masochist) comes in handy.

Before we begin I'd like to reiterate on the difference between gamescripts and gamescripts_r.

  gamescripts scripts and gamescripts_r scripts are functionally identical, meaning their scripts will do the exact same as each other.
    This means you can theoretically put a gamescripts script into gamescripts_r and the game will perform the same.
  gamescripts scripts are NOT run (as far as I know) but they contain debug info.
    This basically means the decompiled scripts are much easier to read than _r's.
  As far as I know, there is NO reason to modify scripts in gamescripts.bnk because they're not run.
  
  
  gamescripts_r scripts ARE run but their debug info has been stripped, meaning they're harder to read.
  This also means _r scripts are also smaller in filesize.

----------unluac Usage
(Requires Java. Recommend having Java in the path variable in Windows, otherwise you'll have to specify where Java is every time)
To use unluac you'll have to either use cmd/powershell or create a batch file to automatically process any compiled lua script you pass it.
When you pass unluac a compiled script it will automatically output it to the terminal. This is okay for reading it but not for modifying it.
To output it to a file, you'll want to do:
java -jar unluac.jar "\bnkname\scriptname.lua" >> "scriptname.txt"
This will write the decompiled script to a file called "scriptname.txt" in the folder that unluac is in. (or the working directory?)
Do NOT change the scripts filename from what it was when you extracted it from the bnk, otherwise CompileCompressReplace will not be able to find it in the bnk when replacing.
You may change the extension of the decompiled file to whatever you want, however. E.g You can change it from scriptname.lua to scriptname.txt or anything else.

Like I said, you can create a batch file instead to automatically do this so you don't have to write that line out into the terminal every time.
  You'll probably need some basic knowledge of Windows command line to do this.
Also, be careful if you decompile the same file again. Make sure you delete the old output before decompiling it again otherwise you'll end up with the script repeating in the file.

----------Before You Go Modifying a Lua Script in a bnk----------
As I said earlier, a modified script cannot be bigger than the original.
The reason for this is that if it is, it will start overwriting the next file in the bnk.
Imagine the script is a chapter in a book. You can change things in this chapter, but you can't write any more words without writing into the next chapter.

As I also said earlier, there is a solution.
We can use a function (defined by the game) called RunScript().
This function basically loads and runs another script of our choosing.
The great thing about this function is that it can also load external scripts, scripts outside of bnks!
This means that we can create a brand new script in one of the game's folders and call RunScript on it.
The game will then load the file and run all the code within it!
You should know that RunScript will run all code within the external script and *then* continue execution of the current script.

Remember that book analogy?
Basically, RunScript() is like inserting a footnote but for code.

So, the key to writing additional code within a script is not to. Instead, you should add a call to RunScript() and pass it the path to your external script.
The code in your external script is basically called as if it is a function, therefor keep in mind local variables will not be accessable from within the external script as the scope will be different.


You may be thinking: "How am I meant to insert a call to RunScript if I can't make the script any bigger?!?"
Well this is an issue that doesn't have a very good solution.
Basically, you'll need to remove some redundant code, or modify a different script that has redundant code to then call RunScript().

Here's an example.
GeneralScriptManager.lua is one of the first scripts that gets run when starting a new game.
It has a couple of redundant lines of code, specifically some calls to print()
print() has no functional use and does not effect the flow of the game at all, it was just for debugging during development.
So we can remove the call to print() and this gives us some precious bytes to put our code in.
We can now write our call to RunScript(), which is all we need to start running our own code on demand.

----I kind of went off the rails here, but i'd highly recommend reading through this as modifying things like quests will probably require it.----

Here's a much more tricky scenario. 
Say you plan on modifying a quest script or something that you can't modify at runtime (due to the fact that the code you want to modify is in a coroutine).
You've also got no space to write any code in the lua file except a single call to RunScript(path)
I'll give you a moment to come up with a solution... Give up? I would too if I were you, took me a few minutes to come up with this.

Solution:
You can transfer the definition of the coroutine function to your own external script, which you can then modify.
It's not necessarily that easy however. Here's where that knowledge of Lua comes in handy.
The external script may not be run in the same environment of the internal script, so any values defined (in this case the coroutine function) may not be defined in the right table.
For example, 
-- in the internal script/function:
sometable.someval = 1
-- may be equal to this in the external script:
someothertable.sometable.someval = 1

At this point, RunScript is not enough.
Let me introduce a native* Lua function called loadfile().
  *not entirely native as it has been modified by Lionhead to work with the 360's filesystem.
loadfile() is very easy to use. Just pass it a filepath like RunScript() and it will return a function without calling it.


E.g myfunction = loadfile("scripts\myscript")
We can then simply do:
myfunction()

Why's this any different? It's not, not yet anyway. There's another step to solving this issue.
We need to set the environment of the function to the same environment of the original script.
I won't explain what an environment is, it's kind self explanatory and a full explanation would require an explanation of lua. (contradictory right?)

To truly solve this issue, we'll need to make use of setfenv() and getfenv().
Here's how i'd do this anyway:

myfunc = loadfile("myscript.txt") -- Load the external script (containing definition of the coroutine function), as a function
setfenv(myfunc, getfenv(1)) -- Set "external script"'s environment to the same as the internal script. (getfenv(1) returns the environment of the internal script)
myfunc() -- call the function


----------Actually modifying a Lua Script in a bnk----------
To do this you'll need to use CompileCompressReplace.py
It's usage is very simple. Pass it:
The path to your modified uncompiled script,
The path to the bnk containing the script to replace,
The path to LuaC.exe
The path to Offzip.exe

If you get a warning about the new script being bigger than the old script, enter n. Otherwise you will probably break the game.
You must find a way to shrink the filesize of the script you're modifying (see last chapter).

You should know that when CompileCompressReplace compiles your script, it strips the debug info, essentially turning a non_r script into an _r script. 
  So here's what I do:
  To understand what a script does, decompile the gamescripts.bnk version of the script and read it.
  I will then modify it and pass it to CompileCompressReplace.py and replace the script in the gamescripts_r bnk.
    Yep, I decompile a script from non_r, modify it, compile it, and replace _r's version with it.
  This does not cause any issues as CompileCompressReplace automatically strips debug info from the non-r version, making it practically identical aside from any modifications we made.
Therefor we basically turn a modified non-r script into a modified _r version.
Confused? Don't worry. Basically, decompile and modify non-r scripts then use CompileCompressReplace to put them in the _r bnk so they get run. 

If you plan on modifying the same script over and over to make tweaks, I would suggest making a batch for this too.
For example:
---
CompressCompileReplace.py ".\somescript.txt" "Xbox360\Fable 2\data\gamescripts_r.bnk" ".\LuaC.exe" ".\Offzip.exe"
---
You can also replace ".\somescript.txt" with %1 and pass your plaintext script to the batch, so you can modify a different script within the same bnk.



----------Got your code running in game?----------
Cool. Frustrated from having to reload the game for every change you make to your code? Same. Solution? Coming right up.

Ok so restarting the game (a 1 minute long process) to load your code is not ideal, and you can't do things like toggle freecam at will.
I haven't found an ingame function that we can use to reload our code, and if I had we'd still need to be able to call it when we want to. Catch-22.
I have come up with a solution though.

Basically, I create a coroutine (with GeneralScriptManager.AddScript(TableContainingUpdateFunction), more on this later).
This coroutine calls RunScript() on another external script, every 2 seconds. 
This external script assigns a global variable every time it's run that I call checksum. I have direct access to this external script through my text editor.
The coroutine checks if this checksum (int) ever changes. If it does, it will call a specific function that is also being defined by the external script.
So, if I want my code to be run I just change the checksum int and save the file, the coroutine sees this, and it will call a certain function within the external script (which I can change while the game is running).

It's a pretty rudimentary system but it works.



